---
title: Progressive web apps
---

= Progressive web apps
The term [Progressive web apps](https://developers.google.com/web/progressive-web-apps/) was coined in
[june 2015](https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/) by Alex Russell
and Frances Berriman to bridge the gap between web apps and native apps. In this article, we will create a fully
functioning progressive web app to show the main concepts in more detail.

== What are progressive web apps?
Progressive web apps (PWA) are web applications that _progress over time_. If you happen to visit a website a lot, it
can be great to cache some of these assets offline or to install it on the homescreen.

It is build on the foundation of [progressive enhancement](https://alistapart.com/article/understandingprogressiveenhancement) and
[responsive web design](https://www.smashingmagazine.com/2011/01/guidelines-for-responsive-web-design). Like any modern
website, it should work for anybody anywhere and use more modern browser features when they are available.

Progressive web apps differ from hybrid apps as they are not installed via an app store (A process where you typically
[loose a lot of potential users](http://blog.gaborcselle.com/2012/10/every-step-costs-you-20-of-users.html)).

They are updated on the server, which costs less to maintain since all users are on the same version. PWA's rely heaviliy on service workers to provide
a native app-like experience.

== Example


In this article, we will build a progressive web app for my hometown's
[bike renting service Velo](https://www.velo-antwerpen.be/en). A lot of cities have such a renting service nowadays as
part of their public transport system. In our app, we want to show the availability of bikes per station (And also show the closest
station, if you wanted to hop onto a bike right away).

TODO: velo-photo

I used [Vue.js](vuejs.org) for this. This application is kept as simple as possible to focus on the PWA-specific parts.
For a real world Vue.js application, you might want to check out Vue's [CLI tool](https://github.com/vuejs/vue-cli).

== Getting Started
First off, we start with a basic web application. The index.html-file will look like this:

```
<!DOCTYPE html>
<html>
    <head>
        <title>MyBike</title>
        <link rel="icon" type="image/png" href="img/favicon.png">
        <link rel="stylesheet" href="main.css" media="all" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
    </head>
    <body>
        <div id="app">
            <div id="logo">
                <img src="img/logo.png" alt="MyBike" />
            </div>
            <ul class="stations">
                <li v-for="station in stations">
                    <div class="station">
                        <div class="status">
                            <img v-if="station.bikes == station.slots" src="img/status-full.png" alt="{{station.address}}" />
                            <img v-else-if="station.bikes > 0" src="img/status-available.png" alt="{{station.address}}" />
                            <img v-else-if="station.bikes == 0" src="img/status-empty.png" alt="{{station.address}}" />
                            <img v-else-if="station.status != OPN" src="img/status-closed.png" alt="{{station.address}}" />
                        </div>
                        <strong>{{station.address}} {{station.addressNumber}}</strong>
                        <div>Bikes: {{station.bikes}} - Slots {{station.slots}}</div>
                    </div>
                </li>
            </ul>
        </div>
        <script src="js/axios.min.js"></script>
        <script src="js/vue.min.js"></script>
        <script src="js/app.js"></script>
    </body>
</html>
```

As you can see we load vue.js here, which will load a view for us based on the data that is coming back from
our http request. To keep it simple, this data is a local JSON file.

```
var app = new Vue({
    el: '#app',
    data: {
        stations: []
    },
    beforeMount: function () {
        this.loadStations();
    },
    methods: {
        loadStations: function () {
            var self = this;
            axios.get('/stations.json')
                .then(function (response) {
                    self.stations = response.data;
                })
                .catch(function (error) {
                    console.log(error);
                });
        }
    }
});
```

We will also have some CSS for a basic design and to make this app responsive.

```
body { color: #242729; font: 15px/1.3 Arial,"Helvetica Neue",Helvetica,sans-serif; margin: 40px 0; }
small { color: #999; }
#app { margin: 0 auto; max-width: 700px; }
#logo { margin-bottom: 40px; text-align: center; }
#logo img { width: 100px; height: auto; }
ul.stations { list-style: none; margin: 0 20px; padding: 0; position: relative; }
ul.stations li { border-bottom: 1px solid #e4e6e8; }
ul.stations li div.station { margin-bottom: 10px; margin-top: 10px; margin-left: 58px; }
ul.stations li div.station:after { content: ''; display: block; clear: both; }
ul.stations li div.station div.status { border-radius: 50%; float: left; margin-left: -58px; width: 48px; }
ul.stations li div.station div.status img { width: 48px; }
```

To see the example for yourself, type the following commands:

```
npm install -g browser-sync
npm start
```

The app will now render beautifully on the different browsers.

TODO: screenshots

= Service workers
[Service workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) are a 
big part of PWAs. They allow you to develop [offline first](http://offlinefirst.org/).
A service worker is a javascript process that runs separately and acts as a programmable proxy
between your application and the network. To avoid 
[man-in-the-middle attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack), service workers 
have to run over https.


In order to notify the browser that you have a service worker available, you have to register it on load. 
We do this in the our `app.js` file. We also check if serviceWorker is a know feature in our browser, so when it's not, 
the app will not crash.

```
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js').then(function() {
        console.log('ServiceWorker registration successful');
    }).catch(function(err) {
        console.log('ServiceWorker registration failed: ', err);
    });
}
```

If you look at the code, you see that we register a seperate javascript file here. This is necassary as the service worker will run 
seperate from your other javascript code. The service worker also has no access to your DOM. `sw.js` should be created at the root-level, so 
not inside the js-folder. 

Let's create `sw.js`:

```javascript
var CACHE_NAME = 'my-bike-v1 ';
var CACHED_URLS = [
    '/',
    '/img/favicon.png',
    '/img/icon-120.png',
    '/img/icon-144.png',
    '/img/icon-152.png',
    '/img/icon-192.png',
    '/img/icon-384.png',
    '/img/logo.png',
    '/img/status-available.png',
    '/img/status-closed.png',
    '/img/status-empty.png',
    '/img/status-full.png',
    '/js/axios.min.js',
    '/js/vue.min.js',
    '/js/app.js',
    '/main.css'
];

self.addEventListener('install', function(event) {
    event.waitUntil(
        caches.open(CACHE_NAME).then(function(cache) {
            return cache.addAll(CACHED_URLS);
        })
    );

});
```

What happens here? A service worker has a specific [lifecycle](https://developers.google.com/web/fundamentals/instant-and-offline/service-worker/lifecycle)
When a service worker is found, the browser will try to install it. `CACHED_URLS` contains all url's that need to be cached. This idea 
follows the [app shell architecture](https://developers.google.com/web/fundamentals/architecture/app-shell), where you cache all static assets, to startup the 
application very quickly. In our case, these are all used files, without the station.json file, as this is the dynamic data here. 

If you try to cache a file that cannot be retrieved, the service worker won't be installed

[image:Service Worker failed to install](/img/0002_error_sw.png)

Once the ServiceWorker is installed, we can listen to the activate-event. 

```javascript
self.addEventListener('activate', function(event) {
    event.waitUntil(
        caches.keys().then(function(cacheNames) {
            cacheNames.map(function(cacheName) {
                if (CACHE_NAME !== cacheName && cacheName.startsWith('my-bike')) {
                    return caches.delete(cacheName);
                }
            })
        })
    );
});
```

There is a difference between a ServiceWorker being installed and the ServiceWorker becoming activated. 
In our code, we want to listen to activate-events, because when a new version of the ServiceWorker becomes active, we want 
to delete our old cache. This is also why `CACHE_NAME` has a version (v1) in it's name. A new version will become v2. 

The last part are fetch 'events'. When the service worker is installed, every request will trigger a fetch event. Inside this event, we can now
return our cached resource, if we have one available. 

Keep in mind that cached resource are only returned the second time
you visit the application, as the first time you were still installing it. Also keep in mind that when you develop,
especially on localhost, that the cache will kick it. Don't forget to clear the cache, or just to open a private window
so you don't get confused.

```javascript
self.addEventListener('fetch', function(event) {
    event.respondWith(
        caches.match(event.request).then(function(response) {
            if (response) {
                return response;
            }
            return fetch(event.request);
        })
    );
});
```

There are a lot of [examples](https://github.com/tjoskar/service-worker-exercises) available for service workers.
Keep in mind that service workers are a relatively new feature, so
[not all browsers support all features yet](https://jakearchibald.github.io/isserviceworkerready)

== Web App Manifest
A web app manifest is a JSON file that follows the [W3Câ€™s specification](https://www.w3.org/TR/appmanifest). It gives
some metadata and notifies the browser that this application can be installed on the home screen.

The file should be added as a link-tag in the html file:

```
<link rel="manifest" href="manifest.json">
```

The file itself is a json-file with the options that you specify.

```
{
  "name": "MyBike",
  "short_name": "MyBike",
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#fff",
  "background_color": "#fff",
  "orientation": "portrait",
  "description": "An app for renting bikes",
  "icons": [{
    "src": "img/icon-120.png",
    "sizes": "120x120",
    "type": "image/png"
  }, {
    "src": "img/icon-144.png",
    "sizes": "144x144",
    "type": "image/png"
  }, {
    "src": "img/icon-152.png",
    "sizes": "152x152",
    "type": "image/png"
  }, {
    "src": "img/icon-192.png",
    "sizes": "192x192",
    "type": "image/png"
  },{
    "src": "img/icon-384.png",
    "sizes": "384x384",
    "type": "image/png"
  }]
}
```

The display option represents the preferred display mode, once it is opened from the home screen.
In most cases, standalone will be the best option for a progressive web app.


TODO: display 'fullscreen', 'browser', 'standalone'.
If you configured the web app manifest correctly, the browser might decide to show an
[Install Banner](https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners/). When and if
the install banner is opened is browser-specifc and can be changed over time.

== Source code
[https://github.com/optis/mybike](https://github.com/optis/mybike)

== Resources